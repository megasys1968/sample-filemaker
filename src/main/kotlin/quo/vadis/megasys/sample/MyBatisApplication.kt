package quo.vadis.megasys.sample

import com.filemaker.jdbc1.CommonJ1ResultSet
import org.springframework.boot.CommandLineRunner
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.stereotype.Controller
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration
import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration
import org.springframework.context.annotation.Profile
import quo.vadis.megasys.sample.db.select
import quo.vadis.megasys.sample.db.タスクMapper
import java.lang.reflect.Field
import java.sql.Time
import java.sql.Timestamp
import java.sql.Types
import java.sql.Date
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime
import java.util.*

@Controller
@SpringBootApplication(exclude = [HibernateJpaAutoConfiguration::class, JpaRepositoriesAutoConfiguration::class])
@Profile("mybatis")
class MyBatisApplication(val taskMapper: タスクMapper) : CommandLineRunner {
  override fun run(vararg args: String?) {
    taskMapper.select {
      allRows()
    }.forEach {
      println(it)
    }
  }
}

fun main(args: Array<String>) {
  System.setProperty("spring.profiles.active", "mybatis")
  runApplication<MyBatisApplication>(*args)
}

class Driver : com.filemaker.jdbc.Driver() {
  override fun connect(p0: String?, p1: Properties?): Connection? {
    return super.connect(p0, p1)?.let { Connection(it) }
  }
}

class Connection(private val conn: java.sql.Connection) : java.sql.Connection by conn {
  override fun prepareStatement(sql: String?): java.sql.PreparedStatement {
    return PreparedStatement(conn.prepareStatement(sql))
  }

  override fun prepareStatement(
    sql: String?,
    resultSetType: Int,
    resultSetConcurrency: Int
  ): java.sql.PreparedStatement {
    return PreparedStatement(conn.prepareStatement(sql, resultSetType, resultSetConcurrency))
  }

  override fun prepareStatement(sql: String?, columnNames: Array<out String>?): java.sql.PreparedStatement {
    return PreparedStatement(conn.prepareStatement(sql, columnNames))
  }

  override fun prepareStatement(sql: String?, columnIndexes: IntArray?): java.sql.PreparedStatement {
    return PreparedStatement(conn.prepareStatement(sql, columnIndexes))
  }

  override fun prepareStatement(sql: String?, autoGeneratedKeys: Int): java.sql.PreparedStatement {
    return PreparedStatement(conn.prepareStatement(sql, autoGeneratedKeys))
  }

  override fun prepareStatement(
    sql: String?,
    resultSetType: Int,
    resultSetConcurrency: Int,
    resultSetHoldability: Int
  ): java.sql.PreparedStatement {
    return PreparedStatement(conn.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability))
  }
}

class PreparedStatement(private val statement: java.sql.PreparedStatement) : java.sql.PreparedStatement by statement {
  override fun executeQuery(): java.sql.ResultSet {
    return ResultSet(statement.executeQuery())
  }

  override fun executeQuery(sql: String?): java.sql.ResultSet {
    return ResultSet(statement.executeQuery(sql))
  }

  override fun getResultSet(): java.sql.ResultSet {
    return ResultSet(statement.resultSet)
  }

  override fun getGeneratedKeys(): java.sql.ResultSet {
    return ResultSet(statement.generatedKeys)
  }

  override fun setObject(parameterIndex: Int , x: Any) {
    when(x) {
      is LocalDateTime -> {
        statement.setTimestamp(parameterIndex, Timestamp.valueOf(x))
      }
      is LocalDate -> {
        statement.setDate(parameterIndex, Date.valueOf(x))
      }
      is LocalTime -> {
        statement.setTime(parameterIndex, Time.valueOf(x))
      }
      else -> statement.setObject(parameterIndex, x)
    }
  }
}

class ResultSet(private val result: java.sql.ResultSet) : java.sql.ResultSet by result {
  companion object {
    val hasFetchedField: Field = CommonJ1ResultSet::class.java.getDeclaredField("hasFetched")
      .also {
        it.isAccessible = true
      }

    val rowsField: Field = CommonJ1ResultSet::class.java.getDeclaredField("rows")
      .also {
        it.isAccessible = true
      }
  }

  override fun <T : Any> getObject(columnIndex: Int, type: Class<T>): T? {
    val sqlType: Int = result.metaData.getColumnType(columnIndex)

    return when (type) {
      Timestamp::class.java ->
        if (sqlType == Types.TIMESTAMP) {
          result.getTimestamp(columnIndex) as? T
        } else {
          throw UnsupportedOperationException("conversion to $type from ${result.metaData.getColumnTypeName(columnIndex)} not supported")
        }

      Date::class.java ->
        if (sqlType == Types.DATE) {
          result.getDate(columnIndex) as? T
        } else {
          throw UnsupportedOperationException("conversion to $type from ${result.metaData.getColumnTypeName(columnIndex)} not supported")
        }

      Time::class.java ->
        if (sqlType == Types.TIME) {
          result.getTime(columnIndex) as? T
        } else {
          throw UnsupportedOperationException("conversion to $type from ${result.metaData.getColumnTypeName(columnIndex)} not supported")
        }

      LocalDateTime::class.java ->
        if (sqlType == Types.TIMESTAMP) {
          result.getTimestamp(columnIndex)?.toLocalDateTime() as? T
        } else {
          throw UnsupportedOperationException("conversion to $type from ${result.metaData.getColumnTypeName(columnIndex)} not supported")
        }

      LocalDate::class.java ->
        if (sqlType == Types.DATE) {
          result.getDate(columnIndex)?.toLocalDate() as? T
        } else {
          throw UnsupportedOperationException("conversion to $type from ${result.metaData.getColumnTypeName(columnIndex)} not supported")
        }

      LocalTime::class.java ->
        if (sqlType == Types.TIME) {
          result.getTime(columnIndex)?.toLocalTime() as? T
        } else {
          throw UnsupportedOperationException("conversion to $type from ${result.metaData.getColumnTypeName(columnIndex)} not supported")
        }

      else -> result.getObject(columnIndex, type)
    }
  }

  override fun <T : Any> getObject(columnLabel: String, type: Class<T>): T? {
    return getObject(this.findColumn(columnLabel), type)
  }

  override fun isClosed(): Boolean {
    if(hasFetchedField.get(result) == false) {
      return false
    }
    return rowsField.get(result) == null
  }
}